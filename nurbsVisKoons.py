import numpy as np
import matplotlib.pyplot as plt

def plot_boundary_curves(
    edges_3d,
    num_plot_points: int = 200,
    padding: float = 0.05
):
    """
    Plot four 3D boundary curves (and their control points) generated by create_boundary_curves_for_coons.

    Parameters
    ----------
    edges_3d : list of length 4
        Each element is a tuple:
            (ctrlpts3d, bspline3d_callable, section_bounds, w, h, d)

        • ctrlpts3d          : list of (x, y, z) control points
        • bspline3d_callable : function f(t) -> np.ndarray((m,3))
        • section_bounds     : list of ((x_lo,x_hi),(y_lo,y_hi),(z_lo,z_hi)) (unused here)
        • w, h, d            : floats for the “width, height, depth” of that curve’s domain

    num_plot_points : int
        Number of parameter samples (t in [t0, t1]) at which to evaluate each BSpline for a smooth curve.

    padding : float
        Fractional padding to add around the computed bounding box (e.g. 0.05 adds 5% margin on all sides).
    """

    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

    # Predefine colors and labels for the four curves (you can change if you like)
    colors = ["tab:blue", "tab:orange", "tab:green", "tab:red"]
    labels = ["Curve 1", "Curve 2", "Curve 3", "Curve 4"]

    # 1) Create a 3D figure and axes
    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(111, projection="3d")

    # We will collect all sampled points & control points to compute bounding‐box later
    all_x = []
    all_y = []
    all_z = []

    # 2) Loop over each edge‐curve
    for idx, (ctrlpts3d, bspline3d, section_bounds, w, h, d) in enumerate(edges_3d):
        # Extract the knot interval [t0, t1] from the BSpline callable:
        # We assume bspline3d was built via our helper, so it "knows" its own t0, t1.
        # Because we don’t have t0,t1 separately, we can sample by repeatedly asking the BSpline’s knotvector:
        #    Instead, we’ll inspect the first and last valid parameter by calling bspline3d on a 1D array:
        #    Here’s a quick trick: call bspline3d with a uniform [0,1] grid, see where it “actually” changes.
        # BUT to keep things simpler, we can sample parameters in [0,1] and trust that the BSpline was defined on [0,1].
        # If your BSpline’s true domain is [t0,t1] ≠ [0,1], replace the next two lines with your actual t0,t1.
        t0 = 0.0
        t1 = 1.0

        # 2a) Sample the curve at `num_plot_points` evenly spaced parameters in [t0, t1].
        t_vals = np.linspace(t0, t1, num_plot_points)
        pts_curve = bspline3d(t_vals)   # shape = (num_plot_points, 3)

        x_vals = pts_curve[:,0]
        y_vals = pts_curve[:,1]
        z_vals = pts_curve[:,2]

        # 2b) Plot the smooth 3D boundary curve
        ax.plot(
            x_vals, y_vals, z_vals,
            color=colors[idx],
            linewidth=2.5,
            label=f"{labels[idx]} (w={w:.1f}, h={h:.1f}, d={d:.1f})"
        )

        # 2c) Scatter‐plot the control points in 3D
        cp_arr = np.array(ctrlpts3d)  # shape = (n_ctrl, 3)
        ax.scatter(
            cp_arr[:,0], cp_arr[:,1], cp_arr[:,2],
            color=colors[idx],
            marker="o", s=40,
            edgecolor="k",
            label=f"{labels[idx]} CPs"
        )

        # 2d) Accumulate for bounding‐box
        all_x.extend(x_vals.tolist())
        all_y.extend(y_vals.tolist())
        all_z.extend(z_vals.tolist())

        # Also include control points in the bounding‐box
        all_x.extend(cp_arr[:,0].tolist())
        all_y.extend(cp_arr[:,1].tolist())
        all_z.extend(cp_arr[:,2].tolist())

    # 3) Compute tight axis limits + padding
    all_x = np.array(all_x)
    all_y = np.array(all_y)
    all_z = np.array(all_z)

    x_min, x_max = all_x.min(), all_x.max()
    y_min, y_max = all_y.min(), all_y.max()
    z_min, z_max = all_z.min(), all_z.max()

    x_range = x_max - x_min
    y_range = y_max - y_min
    z_range = z_max - z_min

    # If any range is zero (degenerate), give it a small nonzero to avoid singular transform:
    if x_range == 0: x_range = 1.0
    if y_range == 0: y_range = 1.0
    if z_range == 0: z_range = 1.0

    x_pad = x_range * padding
    y_pad = y_range * padding
    z_pad = z_range * padding

    ax.set_xlim(x_min - x_pad, x_max + x_pad)
    ax.set_ylim(y_min - y_pad, y_max + y_pad)
    ax.set_zlim(z_min - z_pad, z_max + z_pad)

    # 4) Label axes and add legend
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Boundary Curves for Coons Patch (3D)")

    ax.legend(loc="upper left", fontsize=9)

    # 5) Optionally adjust aspect ratio so that X,Y,Z scales look “equal”
    def set_equal_aspect_3d(ax3d):
        """
        Force a (roughly) equal aspect ratio on the 3D axes, by centering
        and expanding all ranges to the maximum dimension.
        """
        x_mid = 0.5*(x_min + x_max)
        y_mid = 0.5*(y_min + y_max)
        z_mid = 0.5*(z_min + z_max)
        max_radius = 0.5*max(x_range, y_range, z_range)

        ax3d.set_xlim(x_mid - max_radius, x_mid + max_radius)
        ax3d.set_ylim(y_mid - max_radius, y_mid + max_radius)
        ax3d.set_zlim(z_mid - max_radius, z_mid + max_radius)

    set_equal_aspect_3d(ax)

    plt.tight_layout()
    plt.show()



def set_axes_equal(ax):
    """
    Make the 3D axes of `ax` have equal scale, so that spheres (and other objects)
    aren’t distorted. Call this after plotting.
    """
    # Get current limits
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    # Compute ranges
    x_range = abs(x_limits[1] - x_limits[0])
    y_range = abs(y_limits[1] - y_limits[0])
    z_range = abs(z_limits[1] - z_limits[0])

    # Largest half‐range
    max_range = max(x_range, y_range, z_range) / 2.0

    # Midpoints
    x_mid = np.mean(x_limits)
    y_mid = np.mean(y_limits)
    z_mid = np.mean(z_limits)

    # Set all axes to span [mid − max_range, mid + max_range]
    ax.set_xlim3d(x_mid - max_range, x_mid + max_range)
    ax.set_ylim3d(y_mid - max_range, y_mid + max_range)
    ax.set_zlim3d(z_mid - max_range, z_mid + max_range)


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (needed to enable 'projection="3d"')


def plot_edges3d(edges_3d, num_plot_points: int = 200):
    """
    Visualize the four 3D boundary curves generated by assemble_patch_edges_3d_from_four_prototypes.

    Parameters
    ----------
    edges_3d : list of length 4
        Each element is a tuple:
            (ctrlpts3d, bspline3d_callable, section_bounds, t0, t1, z_tag)
        • ctrlpts3d            : list of (x, y, z) control points
        • bspline3d_callable   : function f(t) → array of shape (n_samples, 3)
        • section_bounds       : (not used for plotting here, but passed through)
        • t0, t1               : floats defining the valid parameter range for bspline3d_callable
        • z_tag                : (not used for this plot—always None in our version)

    num_plot_points : int
        How many intermediate samples (t values) to draw along each spline
        so that the curve looks smooth.
    """
    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection="3d")

    # Choose four distinct colors for the 4 curves
    colors = ["tab:blue", "tab:orange", "tab:green", "tab:red"]
    labels = ["Curve 1", "Curve 2", "Curve 3", "Curve 4"]

    for idx, (ctrlpts3d, bspline3d, section_bounds, t0, t1, z_tag) in enumerate(edges_3d):
        # Make a parameter vector from t0→t1
        t_vals = np.linspace(t0, t1, num_plot_points)

        # Evaluate the 3D spline at each t
        # bspline3d should accept a vector of t values and return (num_points, 3)
        pts = bspline3d(t_vals)

        # Extract X, Y, Z arrays
        X = pts[:, 0]
        Y = pts[:, 1]
        Z = pts[:, 2]

        # Plot the smooth 3D spline line
        ax.plot(
            X, Y, Z,
            color=colors[idx],
            linewidth=2,
            label=f"{labels[idx]}"
        )

        # Also scatter its control points as circles
        cp_arr = np.array(ctrlpts3d)  # shape = (n_ctrlpts, 3)
        ax.scatter(
            cp_arr[:, 0], cp_arr[:, 1], cp_arr[:, 2],
            color=colors[idx],
            marker="o",
            s=50,
            edgecolor="k",
            depthshade=True,
            label=f"{labels[idx]} CPs"
        )

    # Tidy up the 3D axes
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("3D Boundary Curves (Assembled Coons Edges)")

    # Combine both “curve lines” and “control points” in one legend
    ax.legend(loc="best", fontsize=9, ncol=2)

    # Optionally tighten the view so the curves fill the frame
    # We can compute the global min/max among all control‐points and spline points:
    all_pts = np.vstack([np.array(c[0]) for c in edges_3d])  # stack all control nets
    # Also add a few spline samples so the bounding box includes curve “bulges” if any:
    for (_, bspline3d, _, t0, t1, _) in edges_3d:
        sample_pts = bspline3d(np.linspace(t0, t1, 10))
        all_pts = np.vstack((all_pts, sample_pts))

    # Now get min/max for each axis
    x_min, y_min, z_min = all_pts.min(axis=0)
    x_max, y_max, z_max = all_pts.max(axis=0)

    # Add a small padding so the curves aren’t exactly on the frame edges
    pad_x = (x_max - x_min) * 0.05
    pad_y = (y_max - y_min) * 0.05
    pad_z = (z_max - z_min) * 0.05

    ax.set_xlim(x_min - pad_x, x_max + pad_x)
    ax.set_ylim(y_min - pad_y, y_max + pad_y)
    ax.set_zlim(z_min - pad_z, z_max + pad_z)

    # Equal aspect ratio is tricky in matplotlib’s 3D, but this helps a bit:
    def set_equal_aspect(ax_3d):
        """Force a roughly equal aspect ratio in 3D by setting identical ranges."""
        x_range = x_max - x_min
        y_range = y_max - y_min
        z_range = z_max - z_min
        max_range = max(x_range, y_range, z_range)
        mid_x = 0.5 * (x_max + x_min)
        mid_y = 0.5 * (y_max + y_min)
        mid_z = 0.5 * (z_max + z_min)
        ax_3d.set_xlim(mid_x - max_range/2, mid_x + max_range/2)
        ax_3d.set_ylim(mid_y - max_range/2, mid_y + max_range/2)
        ax_3d.set_zlim(mid_z - max_range/2, mid_z + max_range/2)

    set_equal_aspect(ax)
    plt.tight_layout()
    plt.show()



import numpy as np
import matplotlib.pyplot as plt

def get_camera_direction(ax):
    """
    Return a unit vector pointing from the camera into the scene,
    based on the Axes3D elevation and azimuth angles.
    """
    # matplotlib stores elevation and azimuth (in degrees) on the Axes3D object:
    elev = np.deg2rad(ax.elev)   # convert to radians
    azim = np.deg2rad(ax.azim)

    # Spherical‐to‐Cartesian conversion for a direction vector:
    dx =  np.cos(elev) * np.cos(azim)
    dy =  np.cos(elev) * np.sin(azim)
    dz =  np.sin(elev)

    # Return as a unit vector
    vec = np.array([dx, dy, dz])
    return vec / np.linalg.norm(vec)



def plot_curve_projections(edge_3d, num_samples: int = 200):
    """
    Plot the projection of a single 3D NURBS curve onto the XY and XZ planes.

    Parameters
    ----------
    edge_3d : tuple
        A tuple defining one boundary‐curve in 3D, of the form
            (ctrlpts3d, bspline3d_callable, section_bounds, t0, t1, z_tag)
        • ctrlpts3d            : list of (x, y, z) control points
        • bspline3d_callable   : function f(t_scalar) → np.ndarray of shape (n, 3)
        • section_bounds       : unused here
        • t0, t1               : floats giving the valid parameter range
        • z_tag                : unused here
    num_samples : int
        Number of samples to draw along the curve when plotting.

    This will open a Matplotlib figure with two side‐by‐side subplots:
      – Left:  XY projection (X vs Y)
      – Right: XZ projection (X vs Z)
    Control points are overlaid as scattered markers in each projection.
    """
    ctrlpts3d, bspline3d, _sec, t0, t1, _tag = edge_3d

    # 1) Sample the curve uniformly in parameter space [t0, t1]
    t_vals = np.linspace(t0, t1, num_samples)
    pts    = bspline3d(t_vals)  # shape = (num_samples, 3)

    # 2) Extract coordinates
    x_curve = pts[:, 0]
    y_curve = pts[:, 1]
    z_curve = pts[:, 2]

    # 3) Extract control‐point arrays
    cp_arr = np.array(ctrlpts3d)  # shape = (n_ctrl, 3)
    x_cp = cp_arr[:, 0]
    y_cp = cp_arr[:, 1]
    z_cp = cp_arr[:, 2]

    # 4) Create figure with two subplots
    fig, (ax_xy, ax_xz) = plt.subplots(1, 2, figsize=(12, 5))

    # --- Plot XY projection ---
    ax_xy.plot(x_curve, y_curve, color="tab:blue", lw=2, label="Curve (XY)")
    ax_xy.scatter(x_cp, y_cp, color="tab:red", s=40, edgecolor="k", zorder=5, label="Control pts")
    ax_xy.set_xlabel("X")
    ax_xy.set_ylabel("Y")
    ax_xy.set_title("Projection onto XY plane")
    ax_xy.axis("equal")
    ax_xy.grid(alpha=0.3)
    ax_xy.legend(loc="upper right", fontsize=9)

    # --- Plot XZ projection ---
    ax_xz.plot(x_curve, z_curve, color="tab:green", lw=2, label="Curve (XZ)")
    ax_xz.scatter(x_cp, z_cp, color="tab:orange", s=40, edgecolor="k", zorder=5, label="Control pts")
    ax_xz.set_xlabel("X")
    ax_xz.set_ylabel("Z")
    ax_xz.set_title("Projection onto XZ plane")
    ax_xz.axis("equal")
    ax_xz.grid(alpha=0.3)
    ax_xz.legend(loc="upper right", fontsize=9)

    plt.tight_layout()
    plt.show()


def plot_coons_surface_and_edges(surface_pts: np.ndarray,
                                 edges_3d: list,
                                 edge_plot_samples: int = 10000,
                                 surface_alpha: float = 0.7,
                                 cmap: str = "viridis"):
    """
    Visualize a Coons patch surface (from surface_pts) together with its four boundary curves.

    Parameters
    ----------
    surface_pts : np.ndarray, shape (num_v, num_u, 3)
        The grid of interpolated points returned by interpolate_coons_patch.
        Indexing: surface_pts[v, u, :] gives (X, Y, Z).

    edges_3d : list of length 4
        Each element is a tuple (ctrlpts_3d, bspline_3d_callable, section_bounds, t0, t1, z_tag),
        in the order [D0 (bottom), D1 (top), C0 (left), C1 (right)].

        - ctrlpts_3d: list of 3D control‐points (not used here except for optional plotting)
        - bspline_3d_callable: function f(t_scalar)→np.ndarray shape (3,) that evaluates the NURBS
        - section_bounds: unused in this plot
        - t0, t1: floats defining the valid parameter‐range for that edge
        - z_tag: unused here

    edge_plot_samples : int
        Number of samples to draw along each boundary curve (for smoothness).

    surface_alpha : float
        Transparency of the Coons surface (0.0 fully transparent → 1.0 fully opaque).

    cmap : str
        A Matplotlib colormap for the surface.
    """
    num_v, num_u, _ = surface_pts.shape

    # 1) Extract X, Y, Z grid for the surface
    X = surface_pts[:, :, 0]  # shape (num_v, num_u)
    Y = surface_pts[:, :, 1]
    Z = surface_pts[:, :, 2]

    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection="3d")

    # 2) Plot the Coons patch as a semi-transparent surface
    surf = ax.plot_surface(
        X, Y, Z,
        rstride=1, cstride=1,
        cmap=cmap,
        alpha=surface_alpha,
        edgecolor="none"
    )

    # 3) Overlay each of the four boundary curves
    #    We'll sample each curve at 'edge_plot_samples' points between t0→t1.
    curve_colors = ["tab:blue", "tab:orange", "tab:green", "tab:red"]
    curve_labels = ["D0 (bottom)", "D1 (top)", "C0 (left)", "C1 (right)"]

    for idx, (ctrlpts3d, bspline3d, section_bounds, t0, t1, z_tag) in enumerate(edges_3d):
        # Sample parameter values uniformly in [t0, t1]
        t_values = np.linspace(t0, t1, edge_plot_samples)
        pts_curve = bspline3d(t_values)  # shape (edge_plot_samples, 3)

        ax.plot(
            pts_curve[:, 0],
            pts_curve[:, 1],
            pts_curve[:, 2],
            color=curve_colors[idx],
            linewidth=2.5,
            label=curve_labels[idx]
        )

        # Optionally, plot control‐points as markers (uncomment if desired):
        # cp_arr = np.array(ctrlpts3d)
        # ax.scatter(
        #     cp_arr[:, 0], cp_arr[:, 1], cp_arr[:, 2],
        #     color=curve_colors[idx],
        #     marker="o", s=40,
        #     edgecolor="k",
        #     label=f"{curve_labels[idx]} CPs"
        # )

    # 4) Label axes
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Coons Patch Surface + Boundary Curves")

    # 5) Set a reasonable 3D aspect ratio so that axes scale equally
    #    (Matplotlib 3D doesn’t do this automatically, so we manually enforce it)
    def set_equal_aspect(ax3d):
        # Compute ranges in each dimension
        x_vals = surface_pts[:, :, 0].ravel()
        y_vals = surface_pts[:, :, 1].ravel()
        z_vals = surface_pts[:, :, 2].ravel()
        # Include curve endpoints as well
        for (_, bspline3d, _, t0c, t1c, _) in edges_3d:
            samp = bspline3d(np.linspace(t0c, t1c, 10))
            x_vals = np.concatenate((x_vals, samp[:, 0]))
            y_vals = np.concatenate((y_vals, samp[:, 1]))
            z_vals = np.concatenate((z_vals, samp[:, 2]))
        x_min, x_max = x_vals.min(), x_vals.max()
        y_min, y_max = y_vals.min(), y_vals.max()
        z_min, z_max = z_vals.min(), z_vals.max()

        max_range = np.array([x_max - x_min, y_max - y_min, z_max - z_min]).max() / 2.0
        mid_x = (x_max + x_min) * 0.5
        mid_y = (y_max + y_min) * 0.5
        mid_z = (z_max + z_min) * 0.5

        ax3d.set_xlim(mid_x - max_range, mid_x + max_range)
        ax3d.set_ylim(mid_y - max_range, mid_y + max_range)
        ax3d.set_zlim(mid_z - max_range, mid_z + max_range)

    set_equal_aspect(ax)

    # 6) Show legend
    ax.legend(loc="upper left")

    # 7) Display
    plt.tight_layout()
    plt.show()



import numpy as np
import matplotlib.pyplot as plt

def visualize_dataset_entry(entry, num_samples=50):
    """
    Visualize a single dataset entry (as generated by create_dataset_entry in the new Coons-patch pipeline).
    Colors control-net points based on depth relative to the current camera view:
      • “in front” (dot > 0) → red
      • “behind”  (dot < 0) → blue

    Args:
        entry (dict): A dataset entry containing:
                      - "points"       : np.ndarray of surface points (V×U×3), already rotated/noisy/normalized
                      - "control_net"  : np.ndarray of control-net points (m×n×3), rotated/normalized
                      - "rotation_angle": tuple (rx, ry, rz) of applied rotation angles (radians)
        num_samples (int): Unused here (only kept for signature compatibility).
    """
    # Fetch from the entry keys
    surface_pts = entry["points"]         # shape (V, U, 3)
    control_net = entry["control_net"]    # shape (m, n, 3)
    rot_angle   = entry["rotation_angle"]

    fig = plt.figure(figsize=(14, 10))
    ax = fig.add_subplot(111, projection='3d')

    # 1) Plot the (flattened) noisy surface points
    pts_flat = surface_pts.reshape(-1, 3)
    ax.scatter(
        pts_flat[:, 0], pts_flat[:, 1], pts_flat[:, 2],
        color='magenta', marker='.', s=20,
        label="Noisy Surface Points", zorder=5
    )

    # 2) Prepare control-net for coloring by camera depth
    try:
        size_u, size_v, _ = control_net.shape
    except Exception:
        size_u = size_v = 0
    flat_cn = control_net.reshape(-1, 3)

    # 3) Compute camera direction from current view
    cam_dir = get_camera_direction(ax)

    # 4) Compute centroid of control-net
    center_cn = flat_cn.mean(axis=0)

    # 5) For each control-point, compute dot((pt - center), cam_dir)
    vecs = flat_cn - center_cn
    dots = np.dot(vecs, cam_dir)
    colors_cn = np.where(dots > 0, 'red', 'blue')

    # 6) Plot control-net points with depth-based coloring
    ax.scatter(
        flat_cn[:, 0], flat_cn[:, 1], flat_cn[:, 2],
        c=colors_cn, marker='o', s=50,
        label="Control Net Points", zorder=10
    )

    # 7) Draw connecting lines in the control-net grid order
    for i in range(size_u):
        ax.plot(
            control_net[i, :, 0],
            control_net[i, :, 1],
            control_net[i, :, 2],
            color='black', linestyle='--', linewidth=2,
            label="Control Net" if i == 0 else "", zorder=11
        )
    for j in range(size_v):
        ax.plot(
            control_net[:, j, 0],
            control_net[:, j, 1],
            control_net[:, j, 2],
            color='black', linestyle='--', linewidth=2,
            zorder=11
        )

    # 8) Title with rotation angles only
    if isinstance(rot_angle, tuple):
        rot_str = ", ".join(f"{a:.2f}" for a in rot_angle)
    else:
        rot_str = f"{rot_angle:.2f}"

    ax.set_title(
        f"Dataset Entry (Camera-Based Coloring)\n"
        f"Rotation Angles: {rot_str} rad"
    )

    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.legend()
    set_axes_equal(ax)
    plt.show()
